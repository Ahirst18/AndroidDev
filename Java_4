Here’s a complete, **detailed step-by-step guide** to display a notification in your Android app when an ISN (Instant Server Notification) is received:

---

### **Step 1: Set Up Notification Permissions**

Before creating notifications, make sure your app has permission to post them.

#### **Step 1.1: Add Permission to Manifest**
In your `AndroidManifest.xml`, add the following permission:

```xml
<uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
```

- For Android 13 (API level 33) and above, users must grant notification permission at runtime. This permission must be added in the manifest for devices running Android 13 and above.

---

### **Step 2: Create a Notification Channel**

Starting from Android 8.0 (API level 26), you need to create a notification channel for displaying notifications. Channels help categorize notifications for better management.

#### **Step 2.1: Create Notification Channel in `MainActivity.java`**

In your `MainActivity` or the class that handles ISN notifications, create a method for setting up the notification channel:

```java
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.os.Build;

private void createNotificationChannel() {
    // Notification channels are only available in Android O and above
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
        CharSequence name = "ISNChannel";
        String description = "Channel for ISN notifications";
        int importance = NotificationManager.IMPORTANCE_DEFAULT;

        // Create the channel with a unique ID
        NotificationChannel channel = new NotificationChannel("ISN_CHANNEL_ID", name, importance);
        channel.setDescription(description);

        // Register the channel with the system
        NotificationManager notificationManager = getSystemService(NotificationManager.class);
        notificationManager.createNotificationChannel(channel);
    }
}
```

#### **Step 2.2: Call `createNotificationChannel()` in `onCreate()`**

In your `MainActivity` or the class handling the ISN:

```java
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    // Other initialization code...

    // Create the notification channel
    createNotificationChannel();
}
```

This ensures the notification channel is created when the app starts, and it will be available for any notifications you want to send.

---

### **Step 3: Implement Notification Display Logic**

Once your app receives an ISN notification, you need to show it in the form of a system notification.

#### **Step 3.1: Create Notification in `MainActivity.java`**

Define a method to display the notification using `NotificationCompat.Builder`:

```java
import androidx.core.app.NotificationCompat;
import androidx.core.app.NotificationManagerCompat;

private void showNotification(String title, String message) {
    // Create a notification using NotificationCompat
    NotificationCompat.Builder builder = new NotificationCompat.Builder(this, "ISN_CHANNEL_ID")
            .setSmallIcon(R.drawable.ic_notification) // Replace with your app's notification icon
            .setContentTitle(title)
            .setContentText(message)
            .setPriority(NotificationCompat.PRIORITY_DEFAULT)
            .setAutoCancel(true); // Notification disappears when the user taps on it

    // Display the notification
    NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this);
    notificationManager.notify(1, builder.build());
}
```

#### **Step 3.2: Integrate Notification with Retrofit Callback**

After your app receives the ISN notification using Retrofit, display it by calling the `showNotification` method:

```java
private void sendSubscriptionDataToServer(String purchaseToken) {
    Retrofit retrofit = new Retrofit.Builder()
            .baseUrl("http://your-server-ip:8080/")
            .addConverterFactory(GsonConverterFactory.create())
            .build();

    NotificationService service = retrofit.create(NotificationService.class);

    Call<Void> call = service.sendNotification(purchaseToken);

    call.enqueue(new Callback<Void>() {
        @Override
        public void onResponse(Call<Void> call, Response<Void> response) {
            if (response.isSuccessful()) {
                // Display notification on successful response
                showNotification("Subscription Update", "Your subscription status was successfully updated.");
            } else {
                showNotification("Subscription Failed", "There was an error updating your subscription.");
            }
        }

        @Override
        public void onFailure(Call<Void> call, Throwable t) {
            // Display notification on failure
            showNotification("Error", "Failed to communicate with the server.");
        }
    });
}
```

Make sure to replace `http://your-server-ip:8080/` with the actual URL of your backend server.

---

### **Step 4: Request Notification Permission at Runtime (For Android 13 and above)**

Starting from Android 13, apps need to request notification permission from users at runtime.

#### **Step 4.1: Check and Request Permission in `MainActivity.java`**

In your `onCreate()` method, check if the notification permission has been granted. If not, request it:

```java
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;
import android.Manifest;
import android.content.pm.PackageManager;

if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
    if (ContextCompat.checkSelfPermission(this, Manifest.permission.POST_NOTIFICATIONS) 
            != PackageManager.PERMISSION_GRANTED) {
        ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.POST_NOTIFICATIONS}, 101);
    }
}
```

#### **Step 4.2: Handle Permission Result**

You should handle the result of the permission request to ensure the user has granted permission for notifications:

```java
@Override
public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
    super.onRequestPermissionsResult(requestCode, permissions, grantResults);
    if (requestCode == 101) {
        if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
            // Permission granted
        } else {
            // Permission denied
        }
    }
}
```

---

### **Step 5: Testing the Setup**

#### **Step 5.1: Test Backend API with Postman**

1. Open Postman and send a **POST** request to `http://localhost:8080/isn/notifications`.
2. In the **Body** tab, select **raw** and **JSON**, and send a sample notification payload (this simulates an ISN):
   ```json
   {
       "purchaseToken": "test-token",
       "status": "active"
   }
   ```

3. Check the logs in IntelliJ IDEA to ensure the request was received.

#### **Step 5.2: Test Notifications in Android App**

1. **Run your app in Android Studio** and simulate an ISN notification from your backend (using Postman or the actual Samsung IAP process).
2. The app should display a system notification when it successfully receives the ISN.

---

### **Step 6: Deploy Backend to Production**

1. **Deploy your Spring Boot backend** to a public cloud service (AWS EC2, Heroku, DigitalOcean, etc.).
2. Update the Retrofit `baseUrl` in your Android app with the public URL of the deployed backend.
3. In the **Samsung Seller Portal**, update the URL for handling Instant Server Notifications to the public URL of your deployed backend.

---

### **Conclusion**

By following these steps, you’ll be able to:

- Set up a notification channel for displaying system notifications.
- Display a notification when your Android app receives a subscription update (via ISN).
- Ensure compatibility with Android 13 and higher by requesting notification permission at runtime.

This setup will ensure users are notified when their subscription status changes or when errors occur during communication with the backend. Let me know if you need any further assistance!
